## Usage
To enable some of these alerts for your applications, you just need to replace  `App_1`, `App_2` and `App_3` with the actual names of your applications. You can refer to the Prometheus metrics to identify the available filters that can be used for each application. Additionally, modify the values in the conditions to reflect the real cases of your applications. These adjustments will ensure that the alerts accurately monitor your specific applications and their scaling needs.

## Alert Expressions
Alert expressions are formed based on `metric_name`, `metric_function`, `metric_interval`, and `filters` parameters. They form alert expressions like: `kube_deployment_status_replicas_available{deployment=\"nginx\"}`, `rate(kube_pod_container_status_restarts_total{container=\"nginx\"}[5m])`, but sometimes we need to have more complex queries like this one: `sum(rate(nginx_ingress_controller_requests{status=~'5..'}[1m])) by (ingress,cluster) / sum(rate(nginx_ingress_controller_requests[1m])) by (ingress) * 100 > 5`.
When you want to create simple queries, use the parameters counted above. And when you need to create complex queries, don't pass those parameters; instead, pass the query string to the `expr` variable. Check the `tests/expressions` folder for an example with complex queries."

## Conditions and Thresholds
Alert conditions are formed based on $B blocks and `equation`, `threshold` parameters users pass to the module.
`equation` parameter can only get these values:
- `lt` corresponds to `<`
- `gt` corresponds to `>`
- `e` corresponds to `=`
- `lte` corresponds to `<=`
- `gte` corresponds to `>=`

And `threshold` parameter is the number value against which B blocks are compared in the math expression.

## Priority
Specify alert rule priority by passing the priority parameter to the alert_rules variable. By default, the value will be P2. For example, you can set the value to P1 and configure it so that alerts with P1 priority will be sent to Opsgenie, while the other alerts will be sent to Slack.

<!-- BEGINNING OF PRE-COMMIT-TERRAFORM DOCS HOOK -->
## Requirements

| Name | Version |
|------|---------|
| <a name="requirement_terraform"></a> [terraform](#requirement\_terraform) | >= 1.3.0 |
| <a name="requirement_grafana"></a> [grafana](#requirement\_grafana) | >= 1.40.0 |

## Providers

No providers.

## Modules

| Name | Source | Version |
|------|--------|---------|
| <a name="module_alert_rules"></a> [alert\_rules](#module\_alert\_rules) | ../alert-rules | n/a |
| <a name="module_contact_points"></a> [contact\_points](#module\_contact\_points) | ../alert-contact-points | n/a |
| <a name="module_notifications"></a> [notifications](#module\_notifications) | ../alert-notifications | n/a |

## Resources

No resources.

## Inputs

| Name | Description | Type | Default | Required |
|------|-------------|------|---------|:--------:|
| <a name="input_alert_interval_seconds"></a> [alert\_interval\_seconds](#input\_alert\_interval\_seconds) | The interval, in seconds, at which all rules in the group are evaluated. If a group contains many rules, the rules are evaluated sequentially. | `number` | `10` | no |
| <a name="input_contact_points"></a> [contact\_points](#input\_contact\_points) | Grafana contact points configs. | <pre>object({<br>    slack = optional(list(object({                                                         # Slack contact points list<br>      name                    = string                                                     # The name of the contact point<br>      endpoint_url            = optional(string, "https://slack.com/api/chat.postMessage") # Use this to override the Slack API endpoint URL to send requests to<br>      icon_emoji              = optional(string, "")                                       # The name of a Slack workspace emoji to use as the bot icon<br>      icon_url                = optional(string, "")                                       # A URL of an image to use as the bot icon<br>      recipient               = optional(string, null)                                     # Channel, private group, or IM channel (can be an encoded ID or a name) to send messages to<br>      text                    = optional(string, "")                                       # Templated content of the message<br>      title                   = optional(string, "")                                       # Templated title of the message<br>      token                   = optional(string, "")                                       # A Slack API token,for sending messages directly without the webhook method<br>      webhook_url             = optional(string, "")                                       # A Slack webhook URL,for sending messages via the webhook method<br>      username                = optional(string, "")                                       # Username for the bot to use<br>      disable_resolve_message = optional(bool, false)                                      # Whether to disable sending resolve messages<br>    })), [])<br>    opsgenie = optional(list(object({                                                  # OpsGenie contact points list<br>      name                    = string                                                 # The name of the contact point<br>      api_key                 = string                                                 # The OpsGenie API key to use<br>      auto_close              = optional(bool, false)                                  # Whether to auto-close alerts in OpsGenie when they resolve in the Alert manager<br>      message                 = optional(string, "")                                   # The templated content of the message<br>      api_url                 = optional(string, "https://api.opsgenie.com/v2/alerts") # Allows customization of the OpsGenie API URL<br>      disable_resolve_message = optional(bool, false)                                  # Whether to disable sending resolve messages<br>    })), [])<br>    webhook = optional(list(object({                     # Contact points that send notifications to an arbitrary webhook, using the Prometheus webhook format<br>      name                      = string                 # The name of the contact point<br>      url                       = string                 # The URL to send webhook requests to<br>      authorization_credentials = optional(string, null) # Allows a custom authorization scheme - attaches an auth header with this value. Do not use in conjunction with basic auth parameters<br>      authorization_scheme      = optional(string, null) # Allows a custom authorization scheme - attaches an auth header with this name. Do not use in conjunction with basic auth parameters<br>      basic_auth_password       = optional(string, null) # The password component of the basic auth credentials to use<br>      basic_auth_user           = optional(string, null) # The username component of the basic auth credentials to use<br>      disable_resolve_message   = optional(bool, false)  # Whether to disable sending resolve messages. Defaults to<br>      settings                  = optional(any, null)    # Additional custom properties to attach to the notifier<br>    })), [])<br>  })</pre> | `null` | no |
| <a name="input_disable_provenance"></a> [disable\_provenance](#input\_disable\_provenance) | Allow modifying the resources from other sources than Terraform or the Grafana API | `bool` | `true` | no |
| <a name="input_notifications"></a> [notifications](#input\_notifications) | Represents the configuration options for Grafana notification policies. This config is global for grafana and overrides existing configs. | <pre>object({<br>    contact_point   = optional(string, "Slack")       # The default contact point to route all unmatched notifications to<br>    group_by        = optional(list(string), ["..."]) # A list of alert labels to group alerts into notifications by<br>    group_interval  = optional(string, "5m")          # Minimum time interval between two notifications for the same group<br>    repeat_interval = optional(string, "4h")          # Minimum time interval for re-sending a notification if an alert is still firing<br><br>    mute_timing = optional(object({                  # Mute timing config, which will be applied on all policies<br>      name = optional(string, "Default mute timing") # the name of mute timing<br>      intervals = optional(list(object({             # the mute timing interval configs<br>        weekdays      = optional(string, null)<br>        days_of_month = optional(string, null)<br>        months        = optional(string, null)<br>        years         = optional(string, null)<br>        location      = optional(string, null)<br>        times = optional(object({<br>          start = optional(string, "00:00")<br>          end   = optional(string, "24:59")<br>        }), null)<br>      })), [])<br>    }), null)<br><br>    policies = optional(list(object({<br>      contact_point = optional(string, null) # The contact point to route notifications that match this rule to<br>      continue      = optional(bool, true)   # Whether to continue matching subsequent rules if an alert matches the current rule. Otherwise, the rule will be 'consumed' by the first policy to match it<br>      group_by      = optional(list(string), ["..."])<br><br>      matchers = optional(list(object({<br>        label = optional(string, "priority") # The name of the label to match against<br>        match = optional(string, "=")        # The operator to apply when matching values of the given label. Allowed operators are = for equality, != for negated equality, =~ for regex equality, and !~ for negated regex equality<br>        value = optional(string, "P1")       # The label value to match against<br>      })), [])<br>      policies = optional(list(object({ # sub-policies(there is also possibility to implement also ability for sub.sub.sub-policies, but for not seems existing configs are enough)<br>        contact_point = optional(string, null)<br>        continue      = optional(bool, true)<br>        group_by      = optional(list(string), ["..."])<br>        mute_timings  = optional(list(string), [])<br><br>        matchers = optional(list(object({<br>          label = optional(string, "priority")<br>          match = optional(string, "=")<br>          value = optional(string, "P1")<br>        })), [])<br>      })), [])<br>    })), [])<br>  })</pre> | `{}` | no |
| <a name="input_rules"></a> [rules](#input\_rules) | This variable describes alert folders, groups and rules. | <pre>list(object({<br>    name                 = string                                    # The name of the alert rule<br>    no_data_state        = optional(string, "NoData")                # Describes what state to enter when the rule's query returns No Data<br>    exec_err_state       = optional(string, "Error")                 # Describes what state to enter when the rule's query is invalid and the rule cannot be executed<br>    summary              = optional(string, null)                    # Rule annotation as a summary, if not passed automatically generated based on data<br>    labels               = optional(map(any), { "priority" : "P1" }) # Labels help to define matchers in notification policy to control where to send each alert<br>    folder_name          = optional(string, "Main Alerts")           # Grafana folder name in which the rule will be created, the folder name used also as alert group name with suffix " Group"<br>    datasource           = string                                    # Name of the datasource used for the alert<br>    expr                 = optional(string, null)                    # Full expression for the alert<br>    metric_name          = optional(string, "")                      # Prometheus metric name which queries the data for the alert<br>    metric_function      = optional(string, "")                      # Prometheus function used with metric for queries, like rate, sum etc.<br>    metric_interval      = optional(string, "")                      # The time interval with using functions like rate<br>    settings_mode        = optional(string, "replaceNN")             # The mode used in B block, possible values are Strict, replaceNN, dropNN<br>    settings_replaceWith = optional(number, 0)                       # The value by which NaN results of the query will be replaced<br>    filters              = optional(any, null)                       # Filters object to identify each service for alerting<br>    function             = optional(string, "mean")                  # One of Reduce functions which will be used in B block for alerting<br>    equation             = string                                    # The equation in the math expression which compares B blocks value with a number and generates an alert if needed. Possible values: gt, lt, gte, lte, e<br>    threshold            = number                                    # The value against which B blocks are compared in the math expression<br>  }))</pre> | `null` | no |

## Outputs

No outputs.
<!-- END OF PRE-COMMIT-TERRAFORM DOCS HOOK -->
